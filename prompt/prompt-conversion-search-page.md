# 조회 화면 컨버전 프롬프트

## 1. 변환 목표
- 기존 화면의 기능적 요소만 유지하고 UI/스타일링은 {결과참조} 기반으로 재구성
- 데이터 구조와 비즈니스 로직 중심의 변환
- 재사용 가능한 컴포넌트 최대 활용

## 2. 변환 프로세스
### 2.1 초기 분석
- 원본 소스: {원본소스}
- 참조 결과: {결과참조}
- 라우터 파일: {라우터파일참조}
- 라우팅 URL: {라우터url참조}

### 2.2 필수 요소 추출
1. 검색 조건
   - 검색 필드 정의
   - 입력 컴포넌트 타입
   - 검색 로직

2. 조회 결과
   - 테이블 컬럼 정의
   - 데이터 구조
   - 정렬/필터링 로직

### 2.3 컴포넌트 구조화
1. 메인 컴포넌트 (index.tsx)
   - 레이아웃 구성
   - 상태 관리
   - API 연동

2. 검색 조건 컴포넌트
   - 검색조건 컴포넌트
   - {결과참조}에서 사용하는 컴포넌트 패턴 준수

3. 조회 결과 컴포넌트
   - 테이블 컴포넌트
   - 컬럼 정의
   - 페이지네이션
   - 정렬/필터링

### 2.4 상태 관리
- 검색 조건 상태를 zustand 스토어로 관리 

## 3. 파일 구조
```
features/
  ├── {feature-name}/
  │   ├── index.tsx                    # 메인 컴포넌트
  │   ├── types/                       # 타입 정의
  │   │   └── {feature-name}-types.ts
  │   ├── api/                         # API 연동
  │   │   └── {feature-name}-api.ts
  │   ├── store/                       # 화면 상태 관리
  │   │   └── {feature-name}-store.ts
  │   └── ui/                          # UI 컴포넌트
  │       ├── {feature-name}-filter.tsx    # 검색 조건
  │       ├── {feature-name}-table.tsx     # 조회 결과
  │       └── {feature-name}-columns.tsx   # 컬럼 정의
```

## 4. 코드 작성 가이드라인
### 4.1 타입 정의
- 인터페이스/타입 명확히 정의
- API 응답 타입 포함
- 컴포넌트 Props 타입 정의

### 4.2 컴포넌트 작성
- 함수형 컴포넌트 사용
- Props 타입 명시
- 적절한 주석 추가
- 재사용성 고려

### 4.3 상태 관리
- 로컬 상태는 useState
- 전역 상태는 zustand

### 4.4 API 연동
- API 함수 모듈화
- 에러 처리
- 로딩 상태 관리

## 5. 검증 체크리스트
### 5.1 기능 검증
- [ ] 검색 조건 정상 동작
- [ ] 테이블 데이터 표시
- [ ] 정렬/필터링 기능
- [ ] 페이지네이션

### 5.2 코드 품질
- [ ] 타입 정의 완료
- [ ] 컴포넌트 분리 적절
- [ ] 재사용 컴포넌트 활용
- [ ] 주석 및 문서화

### 5.3 성능
- [ ] 불필요한 리렌더링 방지
- [ ] API 호출 최적화

## 6. 주의사항
- 기존 스타일링 코드 제외
- {결과참조}의 UI/UX 패턴 준수
- 불필요한 커스텀 컴포넌트 생성 지양
- 기존 컴포넌트 재사용 우선



